// Generated by CoffeeScript 1.12.5
(function() {
  var Map;

  Map = (function() {
    function Map() {
      this.w = 27;
      this.h = 15;
      this.tileSize = 60;
      this.canvas = document.getElementById('floor');
      this.ctx = this.canvas.getContext('2d');
      this.generate();
    }

    Map.prototype.generate = function() {
      var j, k, ref, ref1, tiles, x, y;
      tiles = new Array(this.w);
      for (x = j = 0, ref = this.w; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        tiles[x] = new Array(this.h);
        for (y = k = 0, ref1 = this.h; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          if (Math.random() < 0.25 || x === 0 || y === 0 || x === this.w || y === this.h) {
            tiles[x][y] = {
              style: 'W',
              sides: {}
            };
          }
        }
      }
      return this.tiles = tiles;
    };

    Map.prototype.findEdges = function() {
      var j, k, len, len1, ref, row, tile, x, y;
      ref = this.tiles;
      for (x = j = 0, len = ref.length; j < len; x = ++j) {
        row = ref[x];
        for (y = k = 0, len1 = row.length; k < len1; y = ++k) {
          tile = row[y];
          if (tile) {
            if (y > 0) {
              tile.sides.above = this.tiles[x][y - 1];
            }
            if (y < this.h) {
              tile.sides.below = this.tiles[x][y + 1];
            }
            if (x > 0) {
              tile.sides.left = this.tiles[x - 1][y];
            }
            if (x < this.w) {
              tile.sides.right = this.tiles[x + 1][y];
            }
            tile.corners = {
              tl: {
                x: (x + 0) * this.tileSize,
                y: (y + 0) * this.tileSize
              },
              tr: {
                x: (x + 1) * this.tileSize,
                y: (y + 0) * this.tileSize
              },
              bl: {
                x: (x + 0) * this.tileSize,
                y: (y + 1) * this.tileSize
              },
              br: {
                x: (x + 1) * this.tileSize,
                y: (y + 1) * this.tileSize
              }
            };
          }
        }
      }
      return true;
    };

    Map.prototype.moveCorners = function() {
      var j, mx, my, ref, results, variation, x, y;
      variation = 20;
      results = [];
      for (x = j = 0, ref = this.w; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var k, ref1, ref2, ref3, ref4, ref5, results1;
          results1 = [];
          for (y = k = 0, ref1 = this.h; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
            mx = ((x + 1) * this.tileSize) + randInt(-variation / 2, variation);
            my = ((y + 1) * this.tileSize) + randInt(-variation / 2, variation);
            if ((ref2 = this.tiles[x][y]) != null) {
              ref2.corners.br = {
                x: mx,
                y: my
              };
            }
            if ((ref3 = this.tiles[x + 1][y]) != null) {
              ref3.corners.bl = {
                x: mx,
                y: my
              };
            }
            if ((ref4 = this.tiles[x][y + 1]) != null) {
              ref4.corners.tr = {
                x: mx,
                y: my
              };
            }
            results1.push((ref5 = this.tiles[x + 1][y + 1]) != null ? ref5.corners.tl = {
              x: mx,
              y: my
            } : void 0);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Map.prototype.findSides = function() {
      var j, len, ref, results, row, tile, x, y;
      ref = this.tiles;
      results = [];
      for (x = j = 0, len = ref.length; j < len; x = ++j) {
        row = ref[x];
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (y = k = 0, len1 = row.length; k < len1; y = ++k) {
            tile = row[y];
            if (tile) {
              tile.lines = [];
              if (!tile.sides.above) {
                tile.lines.push({
                  x1: tile.corners.tl.x,
                  y1: tile.corners.tl.y,
                  x2: tile.corners.tr.x,
                  y2: tile.corners.tr.y
                });
              }
              if (!tile.sides.left) {
                tile.lines.push({
                  x1: tile.corners.tl.x,
                  y1: tile.corners.tl.y,
                  x2: tile.corners.bl.x,
                  y2: tile.corners.bl.y
                });
              }
              if (!tile.sides.right) {
                tile.lines.push({
                  x1: tile.corners.tr.x,
                  y1: tile.corners.tr.y,
                  x2: tile.corners.br.x,
                  y2: tile.corners.br.y
                });
              }
              if (!tile.sides.below) {
                results1.push(tile.lines.push({
                  x1: tile.corners.bl.x,
                  y1: tile.corners.bl.y,
                  x2: tile.corners.br.x,
                  y2: tile.corners.br.y
                }));
              } else {
                results1.push(void 0);
              }
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    };

    Map.prototype.print = function() {
      var j, len, ref, results, row;
      ref = this.tiles;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        results.push(console.log(row.join()));
      }
      return results;
    };

    Map.prototype.draw = function() {
      this.findEdges();
      this.moveCorners();
      this.findSides();
      this.ctx.fillStyle = '#888';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.drawFloor();
      this.drawWalls(this.ctx);
      return this.drawEdges(this.ctx);
    };

    Map.prototype.drawWalls = function(ctx) {
      var j, len, ref, results, row, tile, x, y;
      ctx.fillStyle = '#111';
      ctx.strokeStyle = '#111';
      ref = this.tiles;
      results = [];
      for (x = j = 0, len = ref.length; j < len; x = ++j) {
        row = ref[x];
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (y = k = 0, len1 = row.length; k < len1; y = ++k) {
            tile = row[y];
            if (tile) {
              ctx.beginPath();
              ctx.moveTo(tile.corners.tl.x, tile.corners.tl.y);
              ctx.lineTo(tile.corners.tr.x, tile.corners.tr.y);
              ctx.lineTo(tile.corners.br.x, tile.corners.br.y);
              ctx.lineTo(tile.corners.bl.x, tile.corners.bl.y);
              ctx.fill();
              results1.push(ctx.stroke());
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    };

    Map.prototype.drawEdges = function(ctx) {
      var j, k, l, len, len1, len2, line, ref, ref1, row, tile, x, y;
      ctx.strokeStyle = 'sandstone';
      ctx.beginPath();
      ref = this.tiles;
      for (x = j = 0, len = ref.length; j < len; x = ++j) {
        row = ref[x];
        for (y = k = 0, len1 = row.length; k < len1; y = ++k) {
          tile = row[y];
          if (tile) {
            ref1 = tile.lines;
            for (l = 0, len2 = ref1.length; l < len2; l++) {
              line = ref1[l];
              ctx.moveTo(line.x1, line.y1);
              ctx.lineTo(line.x2, line.y2);
            }
          }
        }
      }
      return ctx.stroke();
    };

    Map.prototype.drawFloor = function() {
      var colour, hue, hue1, hue2, i, j, k, l, m, results;
      hue1 = randInt(0, 360);
      hue2 = hue1 + 180;
      for (i = j = 0; j <= 100; i = ++j) {
        if (Math.random() > 0.5) {
          hue = hue1;
        } else {
          hue = hue2;
        }
        colour = "hsla(" + (hue + randInt(-20, 40)) + "," + (randInt(0, 10)) + "%," + (randInt(30, 50)) + "%,0.5)";
        this.drawRandomisedRect(randInt(-100, 1600), randInt(-100, 900), randInt(100, 300), randInt(100, 300), colour, 50);
      }
      for (i = k = 0; k <= 100; i = ++k) {
        if (Math.random() > 0.5) {
          hue = hue1;
        } else {
          hue = hue2;
        }
        colour = "hsla(" + (hue + randInt(-10, 20)) + "," + (randInt(0, 10)) + "%," + (randInt(30, 70)) + "%,0.4)";
        this.drawRandomisedRect(randInt(-100, 1600), randInt(-100, 900), randInt(50, 100), randInt(50, 100), colour, 10);
      }
      for (i = l = 0; l <= 1000; i = ++l) {
        if (Math.random() > 0.5) {
          hue = hue1;
        } else {
          hue = hue2;
        }
        colour = "hsla(" + (hue + randInt(-10, 20)) + "," + (randInt(0, 5)) + "%," + (randInt(60, 40)) + "%,0.3)";
        this.drawRandomisedRect(randInt(-10, 1660), randInt(-10, 950), randInt(10, 60), randInt(10, 60), colour, 10);
      }
      results = [];
      for (i = m = 0; m <= 10000; i = ++m) {
        if (Math.random() > 0.5) {
          hue = hue1;
        } else {
          hue = hue2;
        }
        colour = "hsla(" + (hue + randInt(-10, 20)) + "," + (randInt(0, 0)) + "%," + (randInt(60, 40)) + "%,0.5)";
        results.push(this.drawRandomisedRect(randInt(-10, 1660), randInt(-10, 950), randInt(10, 30), randInt(10, 30), colour, 5));
      }
      return results;
    };

    Map.prototype.drawRandomisedRect = function(x, y, w, h, colour, variation) {
      this.ctx.fillStyle = colour;
      this.ctx.beginPath();
      this.ctx.moveTo(x + randInt(0, variation), y + randInt(0, variation));
      this.ctx.lineTo(x + w + randInt(0, variation), y + randInt(0, variation));
      this.ctx.lineTo(x + w + randInt(0, variation), y + h + randInt(0, variation));
      this.ctx.lineTo(x + randInt(0, variation), y + h + randInt(0, variation));
      return this.ctx.fill();
    };

    Map.prototype.lines = function() {
      var j, k, l, len, len1, len2, line, lines, ref, ref1, row, tile;
      lines = [];
      ref = this.tiles;
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        for (k = 0, len1 = row.length; k < len1; k++) {
          tile = row[k];
          if (tile) {
            ref1 = tile.lines;
            for (l = 0, len2 = ref1.length; l < len2; l++) {
              line = ref1[l];
              lines.push([
                {
                  x: line.x1,
                  y: line.y1
                }, {
                  x: line.x2,
                  y: line.y2
                }
              ]);
            }
          }
        }
      }
      return lines;
    };

    return Map;

  })();

  window.Map = Map;

}).call(this);
