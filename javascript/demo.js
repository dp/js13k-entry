// Generated by CoffeeScript 1.12.5
(function() {
  var Game;

  Game = (function() {
    function Game() {
      this.shadowCanvas = document.getElementById('shadows');
      this.shadowCtx = this.shadowCanvas.getContext('2d');
      this.maskCanvas = document.getElementById('light-mask');
      this.maskCtx = this.maskCanvas.getContext('2d');
      this.map = new Map();
      this.map.generate();
      this.map.draw();
      this.pos = {
        x: 10,
        y: 10
      };
      this.changed = true;
      this.points = [];
      this.lines = [];
      this.initLines();
    }

    Game.prototype.update = function(timestamp) {
      var delta;
      if (this.lastTimestamp) {
        delta = (timestamp - this.lastTimestamp) / 1000;
      } else {
        delta = 0;
      }
      this.lastTimestamp = timestamp;
      return this.draw(delta);
    };

    Game.prototype.draw = function(delta) {
      if (!this.changed) {
        return false;
      }
      this.shadowCtx.clearRect(0, 0, this.shadowCanvas.width, this.shadowCanvas.height);
      this.drawOrb();
      this.drawLineShadows();
      this.drawLightMask();
      this.map.drawWalls(this.shadowCtx);
      this.map.drawEdges(this.shadowCtx);
      return this.changed = false;
    };

    Game.prototype.drawOrb = function() {
      var grd, radius;
      radius = 60;
      grd = this.maskCtx.createRadialGradient(this.pos.x, this.pos.y, 10, this.pos.x, this.pos.y, radius);
      grd.addColorStop(0, 'rgba(60,255,255,0.6)');
      grd.addColorStop(0.5, 'rgba(60,255,255,0.2)');
      grd.addColorStop(1, 'rgba(60,255,255,0)');
      this.shadowCtx.fillStyle = grd;
      this.shadowCtx.beginPath();
      this.shadowCtx.arc(this.pos.x, this.pos.y, radius, 0, Math.PI * 2);
      this.shadowCtx.fill();
      grd = this.maskCtx.createRadialGradient(this.pos.x + 3, this.pos.y - 3, 2, this.pos.x, this.pos.y, 7);
      grd.addColorStop(0, '#fff');
      grd.addColorStop(1, '#0ff');
      this.shadowCtx.fillStyle = grd;
      this.shadowCtx.beginPath();
      this.shadowCtx.arc(this.pos.x, this.pos.y, 7, 0, Math.PI * 2);
      this.shadowCtx.fill();
      this.shadowCtx.strokeStyle = '#aff';
      this.shadowCtx.beginPath();
      this.shadowCtx.arc(this.pos.x, this.pos.y, 8, 0, Math.PI * 2);
      return this.shadowCtx.stroke();
    };

    Game.prototype.drawPoints = function() {
      var j, len, p, ref, results;
      this.shadowCtx.fillStyle = '#008';
      ref = this.points;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        this.shadowCtx.beginPath();
        this.shadowCtx.arc(p.x, p.y, 1, 0, Math.PI * 2);
        results.push(this.shadowCtx.fill());
      }
      return results;
    };

    Game.prototype.drawPointRays = function() {
      var angDist, endPoint, j, len, p, ref;
      this.shadowCtx.strokeStyle = '#080';
      this.shadowCtx.beginPath();
      ref = this.points;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        angDist = Vectors.angleDistBetweenPoints(this.pos, p);
        if (angDist.distance < 100) {
          endPoint = Vectors.addVectorToPoint(p, angDist.angle, 200);
          this.shadowCtx.moveTo(p.x, p.y);
          this.shadowCtx.lineTo(endPoint.x, endPoint.y);
        }
      }
      return this.shadowCtx.stroke();
    };

    Game.prototype.drawLines = function() {
      var j, l, len, ref;
      this.shadowCtx.strokeStyle = '#800';
      this.shadowCtx.beginPath();
      ref = this.lines;
      for (j = 0, len = ref.length; j < len; j++) {
        l = ref[j];
        this.shadowCtx.moveTo(l[0].x, l[0].y);
        this.shadowCtx.lineTo(l[1].x, l[1].y);
      }
      return this.shadowCtx.stroke();
    };

    Game.prototype.drawLineShadows = function() {
      var angDist1, angDist2, j, l, len, p1, p2, ref, results;
      ref = this.lines;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        l = ref[j];
        p1 = l[0];
        p2 = l[1];
        angDist1 = Vectors.angleDistBetweenPoints(this.pos, p1);
        angDist2 = Vectors.angleDistBetweenPoints(this.pos, p2);
        if (angDist1.distance < 300 || angDist2.distance < 300) {
          this.shadowCtx.fillStyle = 'rgba(20,20,20,0.6)';
          results.push(this.drawShadow(p1, p2, angDist1.angle, angDist2.angle));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Game.prototype.drawShadow = function(p1, p2, ang1, ang2) {
      var end1, end2;
      this.shadowCtx.beginPath();
      end1 = Vectors.addVectorToPoint(p1, ang1, 900);
      end2 = Vectors.addVectorToPoint(p2, ang2, 900);
      this.shadowCtx.moveTo(p1.x, p1.y);
      this.shadowCtx.lineTo(end1.x, end1.y);
      this.shadowCtx.lineTo(end2.x, end2.y);
      this.shadowCtx.lineTo(p2.x, p2.y);
      this.shadowCtx.lineTo(p1.x, p1.y);
      return this.shadowCtx.fill();
    };

    Game.prototype.drawLightMask = function() {
      var grd, radius;
      radius = 500;
      this.maskCtx.fillStyle = '#000';
      this.maskCtx.fillRect(0, 0, 1680, 950);
      this.maskCtx.globalCompositeOperation = 'destination-out';
      grd = this.maskCtx.createRadialGradient(this.pos.x, this.pos.y, radius / 4, this.pos.x, this.pos.y, radius);
      grd.addColorStop(0, 'white');
      grd.addColorStop(1, 'rgba(255,255,255,0)');
      this.maskCtx.fillStyle = grd;
      this.maskCtx.beginPath();
      this.maskCtx.arc(this.pos.x, this.pos.y, radius, 0, Math.PI * 2);
      this.maskCtx.fill();
      return this.maskCtx.globalCompositeOperation = 'source-over';
    };

    Game.prototype.updateMousePos = function(e) {
      game.pos.x = e.pageX;
      game.pos.y = e.pageY - 10;
      return game.changed = true;
    };

    Game.prototype.initPoints = function() {
      var i, j, results;
      results = [];
      for (i = j = 0; j <= 999; i = ++j) {
        results.push(this.points[i] = {
          x: randInt(50, 1580),
          y: randInt(50, 850)
        });
      }
      return results;
    };

    Game.prototype.initLines = function() {
      return this.lines = this.map.lines();
    };

    return Game;

  })();

  window.randInt = function(min, range) {
    return Math.floor(Math.random() * range) + min;
  };

  window.update = function(timestamp) {
    game.update(timestamp);
    window.requestAnimationFrame(update);
    return true;
  };

  window.initGame = function() {
    window.game = new Game();
    window.requestAnimationFrame(update);
    return document.onmousemove = game.updateMousePos;
  };

  window.Game = Game;

}).call(this);
