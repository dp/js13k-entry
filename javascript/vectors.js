// Generated by CoffeeScript 1.12.5
(function() {
  var Vectors;

  Vectors = {
    originPoint: function() {
      return {
        x: 0,
        y: 0
      };
    },
    degToRad: function(deg) {
      return 0.017453292519943295 * deg;
    },
    radToDeg: function(rad) {
      return 57.29577951308232 * rad;
    },
    rotatePoint: function(point, angle) {
      var angleR, length, x, x1, y, y1;
      x = point[0];
      y = point[1];
      length = Math.sqrt(x * x + y * y);
      angleR = Math.acos(x / length);
      if (y < 0) {
        angleR = 0 - angleR;
      }
      angleR += angle;
      x1 = Math.cos(angleR) * length;
      y1 = Math.sin(angleR) * length;
      return [x1, y1];
    },
    rotatePath: function(path, angle) {
      return path.map((function(_this) {
        return function(p) {
          return _this.rotatePoint(p, angle);
        };
      })(this));
    },
    addVectorToPoint: function(point, angRad, length) {
      var newPoint;
      newPoint = {
        x: 0,
        y: 0
      };
      newPoint.x = point.x + (Math.cos(angRad) * length);
      newPoint.y = point.y + (Math.sin(angRad) * length);
      return newPoint;
    },
    addVectors: function(angle1, length1, angle2, length2) {
      var angleR, lengthR, x1, x2, xR, y1, y2, yR;
      x1 = Math.cos(angle1) * length1;
      y1 = Math.sin(angle1) * length1;
      x2 = Math.cos(angle2) * length2;
      y2 = Math.sin(angle2) * length2;
      xR = x1 + x2;
      yR = y1 + y2;
      lengthR = Math.sqrt(xR * xR + yR * yR);
      if (lengthR === 0) {
        return [0, 0];
      }
      angleR = Math.acos(xR / lengthR);
      if (yR < 0) {
        angleR = 0 - angleR;
      }
      return [angleR, lengthR];
    },
    angleDistBetweenPoints: function(fromPoint, toPoint) {
      var angle, distance, x, y;
      if (fromPoint === toPoint) {
        return 0;
      }
      x = toPoint.x - fromPoint.x;
      y = toPoint.y - fromPoint.y;
      distance = Math.sqrt(x * x + y * y);
      angle = Math.acos(x / distance);
      if (y < 0) {
        angle = 0 - angle;
      }
      return {
        angle: angle,
        distance: distance
      };
    },
    distBetweenPoints: function(fromPoint, toPoint) {
      var x, y;
      if (fromPoint === toPoint) {
        return 0;
      }
      x = toPoint.x - fromPoint.x;
      y = toPoint.y - fromPoint.y;
      return Math.sqrt(x * x + y * y);
    },
    shapesWithinReach: function(shapeA, shapeB) {
      return Vectors.distBetweenPoints(shapeA.position, shapeB.position) < shapeA.reach + shapeB.reach;
    },
    shapeBounds: function(paths) {
      var i, j, len, len1, maxX, maxY, minX, minY, path, point;
      if (paths.length === 0 || paths[0].length === 0 || paths[0][0].length === 0) {
        return {
          minX: 0,
          minY: 0,
          maxX: 0,
          maxY: 0
        };
      }
      minX = maxX = paths[0][0][1];
      minY = maxY = paths[0][0][1];
      for (i = 0, len = paths.length; i < len; i++) {
        path = paths[i];
        for (j = 0, len1 = path.length; j < len1; j++) {
          point = path[j];
          if (point[0] < minX) {
            minX = point[0];
          }
          if (point[0] > maxX) {
            maxX = point[0];
          }
          if (point[1] < minY) {
            minY = point[1];
          }
          if (point[1] > maxY) {
            maxY = point[1];
          }
        }
      }
      return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
      };
    },
    shapeCentre: function(paths) {
      var bounds;
      bounds = this.shapeBounds(paths);
      return {
        x: (bounds.minX + bounds.maxX) / 2,
        y: (bounds.minY + bounds.maxY) / 2
      };
    },
    distFromOrigin: function(x, y) {
      return Math.sqrt(x * x + y * y);
    },
    movePathOrigin: function(paths, originX, originY) {
      var i, len, path, point, results;
      results = [];
      for (i = 0, len = paths.length; i < len; i++) {
        path = paths[i];
        results.push((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = path.length; j < len1; j++) {
            point = path[j];
            if (point.length !== 0) {
              point[0] -= originX;
              results1.push(point[1] -= originY);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    },
    centrePath: function(paths) {
      var centre;
      centre = Vectors.shapeCentre(paths);
      return Vectors.movePathOrigin(paths, centre.x, centre.y);
    },
    centrePathH: function(paths) {
      var centre;
      centre = Vectors.shapeCentre(paths);
      return Vectors.movePathOrigin(paths, centre.x, 0);
    },
    centrePathV: function(paths) {
      var centre;
      centre = Vectors.shapeCentre(paths);
      return Vectors.movePathOrigin(paths, 0, centre.y);
    }
  };

  window.Vectors = Vectors;

}).call(this);
