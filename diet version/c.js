// Generated by CoffeeScript 1.12.5
(function() {
  window.V = {
    m1: function(point, angRad, length) {
      var newPoint;
      newPoint = {
        x: 0,
        y: 0
      };
      newPoint.x = point.x + (Math.cos(angRad) * length);
      newPoint.y = point.y + (Math.sin(angRad) * length);
      return newPoint;
    },
    m2: function(fromPoint, toPoint) {
      var angle, distance, x, y;
      if (fromPoint === toPoint) {
        return 0;
      }
      x = toPoint.x - fromPoint.x;
      y = toPoint.y - fromPoint.y;
      distance = Math.sqrt(x * x + y * y);
      angle = Math.acos(x / distance);
      if (y < 0) {
        angle = 0 - angle;
      }
      return {
        angle: angle,
        distance: distance
      };
    },
    m3: function(fromPoint, toPoint) {
      var x, y;
      if (fromPoint === toPoint) {
        return 0;
      }
      x = toPoint.x - fromPoint.x;
      y = toPoint.y - fromPoint.y;
      return Math.sqrt(x * x + y * y);
    }
  };

  window.L = {
    init: function(lightEl) {
      this.lightEl = lightEl;
      this.on = false;
      this.lightValue = 0;
      this.viewRadius = 0;
      this.alpha = 1.0;
      this.reduction = 7;
      this.tweening = false;
      this.tweenTimePassed = 0;
      this.tweenTime = 0;
      this.tweenTargetRadius = 0;
      this.tweenTargetAlpha = 0;
      this.tweenStartRadius = 0;
      this.tweenStartAlpha = 0;
      this.tweenRadius = 0;
      return this.maxDarkRadius = 40;
    },
    update: function(delta) {
      var multiplier;
      if (this.tweening) {
        this.tweenTimePassed += delta;
        if (this.tweenTimePassed > this.tweenTime) {
          multiplier = 1;
          this.tweening = false;
        } else {
          multiplier = this.tweenTimePassed / this.tweenTime;
        }
        this.viewRadius = (this.tweenTargetRadius - this.tweenStartRadius) * multiplier + this.tweenStartRadius;
        this.alpha = (this.tweenTargetAlpha - this.tweenStartAlpha) * multiplier + this.tweenStartAlpha;
      } else if (this.on) {
        this.lightValue -= this.reduction * delta;
        if (this.lightValue < 1) {
          this.lightValue = 0;
          this.turnOff();
        } else {
          this.viewRadius = this.lightValue;
        }
      } else {
        this.viewRadius = this.maxDarkRadius;
      }
      return this.viewRadius = Math.pow(this.viewRadius, 0.333) * 40;
    },
    turnOff: function(time) {
      if (time == null) {
        time = 2.0;
      }
      this.on = false;
      this.viewRadius = 0;
      this.alpha = 0.0;
      this.tweenTo(time, this.maxDarkRadius, 0.4);
      this.lightEl.style.display = 'none';
      return true;
    },
    turnOn: function(time) {
      if (time == null) {
        time = 1.0;
      }
      if (this.lightValue < 1) {
        return false;
      }
      this.on = true;
      this.tweenTo(time, this.lightValue, 1.0);
      this.lightEl.style.display = 'block';
      return true;
    },
    tweenTo: function(time, radius, alpha) {
      this.tweenTimePassed = 0;
      this.tweenTime = time;
      this.tweening = true;
      this.tweenStartRadius = Math.pow(this.viewRadius / 40, 1 / 0.333);
      this.tweenTargetRadius = radius;
      this.tweenStartAlpha = this.alpha;
      return this.tweenTargetAlpha = alpha;
    },
    addPower: function() {
      this.lightValue += 90;
      return this.turnOn(1.0);
    }
  };

  window.Msg = {
    init: function(ctx1, originX, originY) {
      this.ctx = ctx1;
      this.originX = originX;
      this.originY = originY;
      this.messages = [];
      this.list = [];
      return this.maxTime = 10;
    },
    update: function(delta) {
      var j, len, msg, ref, results;
      ref = this.messages;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        msg = ref[j];
        if (msg.hold > 0) {
          results.push(msg.hold -= delta);
        } else if (msg.fade > 0) {
          results.push(msg.fade -= delta);
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    draw: function() {
      var j, len, msg, ref, results;
      ref = this.messages;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        msg = ref[j];
        if (msg.fade > 0) {
          if (msg.hold <= 0) {
            this.ctx.globalAlpha = msg.fade / msg.fadeTime;
          }
          this.ctx.fillStyle = msg.colour;
          this.ctx.font = msg.font;
          this.ctx.fillText(msg.txt, msg.x, msg.y);
          results.push(this.ctx.globalAlpha = 1.0);
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    say: function(text, args) {
      var gap, i, j, k, len, len1, line, lines, m, msg, ref, results;
      if (args == null) {
        args = {};
      }
      lines = text.split('|');
      args.colour || (args.colour = 'white');
      args.x || (args.x = this.originX - 235);
      args.y || (args.y = 0);
      args.size || (args.size = 18);
      args.hold || (args.hold = 2);
      args.fade || (args.fade = 10);
      results = [];
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        msg = {
          txt: line,
          colour: args.colour,
          size: args.size,
          font: args.size + "px sans-serif",
          x: this.originX + args.x,
          y: this.originY + args.y,
          hold: args.hold,
          fade: args.fade,
          fadeTime: args.fade
        };
        this.messages.push(msg);
        if (!args.y) {
          gap = msg.size + 5;
          if (i === 0) {
            gap += 20;
          }
          ref = this.list;
          for (k = 0, len1 = ref.length; k < len1; k++) {
            m = ref[k];
            m.y -= gap;
          }
          results.push(this.list.push(msg));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  window.Map = {
    init: function() {
      this.w = 120;
      this.h = 80;
      this.tileSize = 25;
      this.seed = 559516;
      this.settings = {
        initialDensity: 0.47,
        reseedDensity: 0.51,
        smoothCorners: true,
        passes: ["combine-aggressive", "reseed-medium", "combine-aggressive", "reseed-small", "combine-aggressive", "remove-singles"],
        reseedMethod: 'top',
        emptyTolerance: 6,
        wallRoughness: 0.2
      };
      this.canvas = document.createElement('canvas');
      this.canvas.width = (this.w + 1) * this.tileSize;
      this.canvas.height = (this.h + 1) * this.tileSize;
      this.canvas.style.width = this.canvas.width + 'px';
      this.ctx = this.canvas.getContext('2d');
      this.floorCanvas = document.createElement('canvas');
      this.floorCanvas.width = (this.w + 1) * this.tileSize;
      this.floorCanvas.height = (this.h + 1) * this.tileSize;
      this.floorCtx = this.floorCanvas.getContext('2d');
      return this.generate();
    },
    generate: function() {
      var j, k, ref, ref1, tiles, x, y;
      tiles = new Array(this.w);
      this.wTiles = new Array(this.w);
      for (x = j = 0, ref = this.w; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        tiles[x] = new Array(this.h);
        this.wTiles[x] = new Array(this.h);
        for (y = k = 0, ref1 = this.h; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          if (this.seededRandom() < this.settings.initialDensity || x === 0 || y === 0 || x === this.w || y === this.h) {
            tiles[x][y] = true;
          }
        }
      }
      return this.tiles = tiles;
    },
    tileAtPos: function(pos) {
      return this.tiles[Math.floor(pox.x / this.tileSize)][Math.floor(pox.y / this.tileSize)];
    },
    generateCellular: function() {
      var j, len, ref, results, row, tile, x, y;
      ref = this.tiles;
      results = [];
      for (x = j = 0, len = ref.length; j < len; x = ++j) {
        row = ref[x];
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (y = k = 0, len1 = row.length; k < len1; y = ++k) {
            tile = row[y];
            if (tile) {
              results1.push(this.tiles[x][y] = {
                style: 'W',
                sides: []
              });
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    },
    cellularPass: function(passType) {
      var count, j, k, n, o, range, ref, ref1, ref2, ref3, x, y;
      for (x = j = 1, ref = this.w; 1 <= ref ? j < ref : j > ref; x = 1 <= ref ? ++j : --j) {
        for (y = k = 1, ref1 = this.h; 1 <= ref1 ? k < ref1 : k > ref1; y = 1 <= ref1 ? ++k : --k) {
          this.wTiles[x][y] = this.tiles[x][y];
          if (passType.match("combine")) {
            if (this.nearbyTiles(x, y, 1) >= 5) {
              if (passType === 'combine-aggressive') {
                this.tiles[x][y] = true;
              }
              this.wTiles[x][y] = true;
            } else {
              if (passType === 'combine-aggressive') {
                this.tiles[x][y] = null;
              }
              this.wTiles[x][y] = null;
            }
          } else if (passType.match("reseed")) {
            if (passType === "reseed-huge") {
              range = 7;
            } else if (passType === "reseed-large") {
              range = 5;
            } else if (passType === "reseed-medium") {
              range = 4;
            } else {
              range = 3;
            }
            if (this.settings.reseedMethod === 'top') {
              if (this.nearbyTiles(x + range, y + range, range) <= this.settings.emptyTolerance) {
                if (this.seededRandom() < this.settings.reseedDensity) {
                  this.wTiles[x][y] = true;
                }
                this.tiles[x][y] = this.wTiles[x][y];
              }
            } else {
              if (this.nearbyTiles(x, y, range) <= this.settings.emptyTolerance) {
                if (this.seededRandom() < this.settings.reseedDensity) {
                  this.wTiles[x][y] = true;
                }
              }
            }
          } else if (passType === 'remove-singles') {
            count = this.nearbyTiles(x, y, 1);
            if (count === 1 && this.tiles[x][y]) {
              this.wTiles[x][y] = null;
            } else if (count === 8 && !this.tiles[x][y]) {
              this.wTiles[x][y] = true;
            }
          }
        }
      }
      for (x = n = 1, ref2 = this.w; 1 <= ref2 ? n < ref2 : n > ref2; x = 1 <= ref2 ? ++n : --n) {
        for (y = o = 1, ref3 = this.h; 1 <= ref3 ? o < ref3 : o > ref3; y = 1 <= ref3 ? ++o : --o) {
          this.tiles[x][y] = this.wTiles[x][y];
        }
      }
      return true;
    },
    nearbyTiles: function(x, y, dist) {
      var count, j, k, ref, ref1, ref2, ref3, xo, yo;
      count = 0;
      for (xo = j = ref = x - dist, ref1 = x + dist; ref <= ref1 ? j <= ref1 : j >= ref1; xo = ref <= ref1 ? ++j : --j) {
        for (yo = k = ref2 = y - dist, ref3 = y + dist; ref2 <= ref3 ? k <= ref3 : k >= ref3; yo = ref2 <= ref3 ? ++k : --k) {
          if (xo < 0 || xo >= this.w || yo < 0 || yo >= this.h) {
            count += 1;
          } else {
            if (this.tiles[xo][yo]) {
              count += 1;
            }
          }
        }
      }
      return count;
    },
    nearbyTile: function(x, y, xOffset, yOffset) {
      return this.tiles[x + xOffset][y + yOffset];
    },
    findEdges: function() {
      var j, k, len, len1, ref, row, tile, x, y;
      ref = this.tiles;
      for (x = j = 0, len = ref.length; j < len; x = ++j) {
        row = ref[x];
        for (y = k = 0, len1 = row.length; k < len1; y = ++k) {
          tile = row[y];
          if (tile) {
            if (y > 0) {
              tile.sides.above = this.tiles[x][y - 1];
            }
            if (y < this.h) {
              tile.sides.below = this.tiles[x][y + 1];
            }
            if (x > 0) {
              tile.sides.left = this.tiles[x - 1][y];
            }
            if (x < this.w) {
              tile.sides.right = this.tiles[x + 1][y];
            }
            tile.corners = {
              tl: {
                x: (x + 0) * this.tileSize,
                y: (y + 0) * this.tileSize
              },
              tr: {
                x: (x + 1) * this.tileSize,
                y: (y + 0) * this.tileSize
              },
              bl: {
                x: (x + 0) * this.tileSize,
                y: (y + 1) * this.tileSize
              },
              br: {
                x: (x + 1) * this.tileSize,
                y: (y + 1) * this.tileSize
              }
            };
            tile.surrounded = this.nearbyTiles(x, y, 1) === 9;
          }
        }
      }
      return true;
    },
    moveCorners: function() {
      var j, key, mx, my, ox, oy, ref, results, variation, x, y;
      variation = this.settings.wallRoughness * this.tileSize;
      results = [];
      for (x = j = 0, ref = this.w; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var k, ref1, ref2, ref3, ref4, ref5, results1;
          results1 = [];
          for (y = k = 0, ref1 = this.h; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
            ox = oy = 0;
            if (this.settings.smoothCorners) {
              key = 0;
              if (this.tiles[x][y]) {
                key += 1;
              }
              if (this.tiles[x + 1][y]) {
                key += 2;
              }
              if (this.tiles[x][y + 1]) {
                key += 4;
              }
              if (this.tiles[x + 1][y + 1]) {
                key += 8;
              }
              if (key === 1 || key === 4 || key === 11 || key === 14) {
                ox = -1;
              } else if (key === 2 || key === 7 || key === 8 || key === 13) {
                ox = 1;
              }
              if (key === 1 || key === 2 || key === 14 || key === 14) {
                oy = -1;
              } else if (key === 4 || key === 7 || key === 8 || key === 11) {
                oy = 1;
              }
              ox = ox * this.tileSize / 4;
              oy = oy * this.tileSize / 4;
            }
            mx = ((x + 1) * this.tileSize) + ox + this.randInt(-variation / 2, variation);
            my = ((y + 1) * this.tileSize) + oy + this.randInt(-variation / 2, variation);
            if ((ref2 = this.tiles[x][y]) != null) {
              ref2.corners.br = {
                x: mx,
                y: my
              };
            }
            if ((ref3 = this.tiles[x + 1][y]) != null) {
              ref3.corners.bl = {
                x: mx,
                y: my
              };
            }
            if ((ref4 = this.tiles[x][y + 1]) != null) {
              ref4.corners.tr = {
                x: mx,
                y: my
              };
            }
            results1.push((ref5 = this.tiles[x + 1][y + 1]) != null ? ref5.corners.tl = {
              x: mx,
              y: my
            } : void 0);
          }
          return results1;
        }).call(this));
      }
      return results;
    },
    findSides: function() {
      var j, len, line, ref, results, row, tile, x, y;
      ref = this.tiles;
      results = [];
      for (x = j = 0, len = ref.length; j < len; x = ++j) {
        row = ref[x];
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (y = k = 0, len1 = row.length; k < len1; y = ++k) {
            tile = row[y];
            if (tile) {
              tile.lines = [];
              if (!tile.sides.above) {
                line = {
                  x1: tile.corners.tl.x,
                  y1: tile.corners.tl.y,
                  x2: tile.corners.tr.x,
                  y2: tile.corners.tr.y
                };
                line.stuff = this.findNormals(line.x1, line.y1, line.x2, line.y2);
                tile.lines.push(line);
              }
              if (!tile.sides.left) {
                line = {
                  x1: tile.corners.tl.x,
                  y1: tile.corners.tl.y,
                  x2: tile.corners.bl.x,
                  y2: tile.corners.bl.y
                };
                line.stuff = this.findNormals(line.x2, line.y2, line.x1, line.y1);
                tile.lines.push(line);
              }
              if (!tile.sides.right) {
                line = {
                  x1: tile.corners.tr.x,
                  y1: tile.corners.tr.y,
                  x2: tile.corners.br.x,
                  y2: tile.corners.br.y
                };
                line.stuff = this.findNormals(line.x1, line.y1, line.x2, line.y2);
                tile.lines.push(line);
              }
              if (!tile.sides.below) {
                line = {
                  x1: tile.corners.bl.x,
                  y1: tile.corners.bl.y,
                  x2: tile.corners.br.x,
                  y2: tile.corners.br.y
                };
                line.stuff = this.findNormals(line.x2, line.y2, line.x1, line.y1);
                results1.push(tile.lines.push(line));
              } else {
                results1.push(void 0);
              }
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    },
    findNormals: function(x1, y1, x2, y2) {
      var angDist, mp;
      mp = 1;
      angDist = V.m2({
        x: x1,
        y: y1
      }, {
        x: x2,
        y: y2
      });
      return {
        mp: mp,
        ang: angDist.angle,
        normal: angDist.angle - Math.PI / 2
      };
    },
    draw: function() {
      var j, len, passType, ref;
      ref = this.settings.passes;
      for (j = 0, len = ref.length; j < len; j++) {
        passType = ref[j];
        this.cellularPass(passType);
      }
      this.generateCellular();
      this.findEdges();
      this.moveCorners();
      this.findSides();
      this.drawFloor();
      this.drawWalls(this.ctx);
      return this.imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    },
    pixelAt: function(x, y) {
      var alpha, blue, green, offset, red;
      x = Math.floor(x);
      y = Math.floor(y);
      offset = ((this.canvas.width * y) + x) * 4;
      red = this.imageData.data[offset];
      green = this.imageData.data[offset + 1];
      blue = this.imageData.data[offset + 2];
      alpha = this.imageData.data[offset + 3];
      return [red, green, blue, alpha];
    },
    drawWalls: function(ctx) {
      var j, len, ref, results, row, tile, x, y;
      ctx.fillStyle = '#585655';
      ctx.strokeStyle = '#585655';
      ref = this.tiles;
      results = [];
      for (x = j = 0, len = ref.length; j < len; x = ++j) {
        row = ref[x];
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (y = k = 0, len1 = row.length; k < len1; y = ++k) {
            tile = row[y];
            if (tile) {
              ctx.beginPath();
              ctx.moveTo(tile.corners.tl.x, tile.corners.tl.y);
              ctx.lineTo(tile.corners.tr.x, tile.corners.tr.y);
              ctx.lineTo(tile.corners.br.x, tile.corners.br.y);
              ctx.lineTo(tile.corners.bl.x, tile.corners.bl.y);
              ctx.fill();
              results1.push(ctx.stroke());
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    },
    drawEdges: function(ctx) {
      var j, k, len, len1, len2, line, n, ref, ref1, row, tile, x, y;
      ctx.strokeStyle = 'sandstone';
      ctx.beginPath();
      ref = this.tiles;
      for (x = j = 0, len = ref.length; j < len; x = ++j) {
        row = ref[x];
        for (y = k = 0, len1 = row.length; k < len1; y = ++k) {
          tile = row[y];
          if (tile) {
            ref1 = tile.lines;
            for (n = 0, len2 = ref1.length; n < len2; n++) {
              line = ref1[n];
              ctx.moveTo(line.x1, line.y1);
              ctx.lineTo(line.x2, line.y2);
            }
          }
        }
      }
      return ctx.stroke();
    },
    drawFloor: function() {
      var brightness, colour, count, hue1, hue2, i, j, k, n, o, p, ref, ref1, ref2, ref3, ref4, results, v1, v2, v3, v4, v5, x, y;
      this.floorCtx.fillStyle = '#888';
      this.floorCtx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      hue1 = this.randInt(0, 360);
      hue2 = hue1 + 180;
      v1 = 5;
      v2 = 10;
      v3 = 3;
      v4 = 1;
      v5 = 4;
      for (x = j = 0, ref = this.w; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = this.h; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
          colour = "hsla(" + (this.randHue(hue1, hue2)) + "," + (this.randInt(0, 5)) + "%," + (this.randInt(60, 20)) + "%,0.5)";
          this.drawRandomisedRect(x * this.tileSize + this.randInt(0, v1), y * this.tileSize + this.randInt(0, v1), this.tileSize + this.randInt(0, v2), this.tileSize + this.randInt(0, v2), colour, v3);
        }
      }
      for (x = n = 0, ref2 = this.w; 0 <= ref2 ? n <= ref2 : n >= ref2; x = 0 <= ref2 ? ++n : --n) {
        for (y = o = 0, ref3 = this.h; 0 <= ref3 ? o <= ref3 : o >= ref3; y = 0 <= ref3 ? ++o : --o) {
          colour = "hsla(" + (this.randHue(hue1, hue2)) + "," + (this.randInt(0, 5)) + "%," + (this.randInt(60, 20)) + "%,0.8)";
          this.drawRandomisedRect(x * this.tileSize + this.randInt(0, v1), y * this.tileSize + this.randInt(0, v1), this.tileSize + this.randInt(0, v2), this.tileSize + this.randInt(0, v2), colour, v3);
        }
      }
      results = [];
      for (x = p = 0, ref4 = this.w; 0 <= ref4 ? p <= ref4 : p >= ref4; x = 0 <= ref4 ? ++p : --p) {
        results.push((function() {
          var q, ref5, results1;
          results1 = [];
          for (y = q = 0, ref5 = this.h; 0 <= ref5 ? q <= ref5 : q >= ref5; y = 0 <= ref5 ? ++q : --q) {
            if (!(this.tiles[x][y] && this.tiles[x][y].surrounded)) {
              count = this.nearbyTiles(x, y, 2);
              brightness = ((1 - (count / 20)) * 80) / 2 + 20;
              results1.push((function() {
                var ref6, results2, s;
                results2 = [];
                for (i = s = 0, ref6 = this.randInt(0, count * 2); 0 <= ref6 ? s <= ref6 : s >= ref6; i = 0 <= ref6 ? ++s : --s) {
                  colour = "hsla(" + (this.randHue(hue1, hue2)) + "," + (this.randInt(0, v1)) + "%," + (this.randInt(brightness, 20)) + "%,0.8)";
                  results2.push(this.drawCircle(x * this.tileSize + this.randInt(0, this.tileSize), y * this.tileSize + this.randInt(0, this.tileSize), this.randInt(v4, v5), colour));
                }
                return results2;
              }).call(this));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    },
    drawRandomisedRect: function(x, y, w, h, colour, variation) {
      this.floorCtx.fillStyle = colour;
      this.floorCtx.beginPath();
      this.floorCtx.moveTo(x + this.randInt(0, variation), y + this.randInt(0, variation));
      this.floorCtx.lineTo(x + w + this.randInt(0, variation), y + this.randInt(0, variation));
      this.floorCtx.lineTo(x + w + this.randInt(0, variation), y + h + this.randInt(0, variation));
      this.floorCtx.lineTo(x + this.randInt(0, variation), y + h + this.randInt(0, variation));
      return this.floorCtx.fill();
    },
    randHue: function(hue1, hue2) {
      var hue;
      if (Math.random() > 0.5) {
        hue = hue1;
      } else {
        hue = hue2;
      }
      return hue + this.randInt(-10, 20);
    },
    drawCircle: function(x, y, r, colour) {
      this.floorCtx.fillStyle = colour;
      this.floorCtx.beginPath();
      this.floorCtx.arc(x, y, r, 0, Math.PI * 2);
      return this.floorCtx.fill();
    },
    lines: function() {
      var j, k, len, len1, len2, line, lines, n, ref, ref1, row, tile;
      lines = [];
      ref = this.tiles;
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        for (k = 0, len1 = row.length; k < len1; k++) {
          tile = row[k];
          if (tile) {
            ref1 = tile.lines;
            for (n = 0, len2 = ref1.length; n < len2; n++) {
              line = ref1[n];
              lines.push([
                {
                  x: line.x1,
                  y: line.y1
                }, {
                  x: line.x2,
                  y: line.y2
                }, line.stuff
              ]);
            }
          }
        }
      }
      return lines;
    },
    seededRandom: function() {
      var x;
      x = Math.sin(this.seed++) * 10000;
      return x - Math.floor(x);
    },
    randInt: function(min, range) {
      return Math.floor(this.seededRandom() * range) + min;
    }
  };

  window.Game = {
    init: function() {
      Map.init();
      Map.draw();
      this.tileSize = Map.tileSize;
      this.state = 0;
      this.orbCount = 0;
      this.distQ = 0;
      this.playerEl = byId('p');
      this.lightEl = byId('l');
      this.playerEl.style.left = ((window.innerWidth - 60) / 2) + "px";
      this.playerEl.style.top = ((window.innerHeight - 48) / 2) + "px";
      this.lightEl.style.left = ((window.innerWidth - 60) / 2) + "px";
      this.lightEl.style.top = ((window.innerHeight - 48) / 2) + "px";
      L.init(this.lightEl);
      this.initGameParams({
        monsters: [[32, 49], [80, 18], [102, 19], [62, 21], [76, 38], [57, 24], [113, 72], [116, 75], [117, 72], [115, 63], [73, 67], [49, 72], [5, 70], [13, 35], [49, 75], [97, 70], [86, 12], [63, 59], [91, 22]],
        orbs: [[60, 61], [35, 33], [10, 62], [18, 48], [105, 77], [114, 50], [116, 16], [49, 29], [73, 38], [80, 5], [79, 72], [101, 58], [72, 45], [80, 49], [51, 46]],
        triggers: [
          {
            x: 116,
            y: 34,
            r: "7",
            msg: "It's like a maze of twisty|passages, they're all alike!"
          }, {
            x: 85,
            y: 59,
            r: "7",
            msg: "I think we're headed|in the right direction"
          }, {
            x: 117,
            y: 69,
            r: "5",
            msg: "I've got a bad feeling|about this ..."
          }, {
            x: 52,
            y: 21,
            r: "7",
            msg: "I think we're almost there!"
          }, {
            x: 57,
            y: 60,
            r: "5",
            msg: "Do we REALLY need|that light?"
          }, {
            x: 77,
            y: 20,
            r: "7",
            msg: "I remember this path..."
          }, {
            x: 32,
            y: 49,
            r: "15",
            msg: "A shadow moves in the|dark"
          }, {
            x: 81,
            y: 49,
            r: "3",
            msg: "It's dangerous to go alone|I should take this"
          }, {
            x: 54,
            y: 74,
            r: "7",
            msg: "Why are they|following me?"
          }, {
            x: 16,
            y: 35,
            r: "3",
            msg: "Are those red dots ...|eyes?"
          }, {
            x: 4,
            y: 51,
            r: "3",
            msg: "I feel like we're|going in circles!"
          }, {
            x: 35,
            y: 32,
            r: "7",
            msg: "Well, that was a waste|of time"
          }
        ]
      });
      this.maskCanvas = byId('lm');
      this.maskCtx = this.maskCanvas.getContext('2d');
      this.maskCanvas.width = Math.floor(window.innerWidth / 2);
      this.maskCanvas.height = Math.floor(window.innerHeight / 2);
      this.maskCanvas.style.width = window.innerWidth + 'px';
      this.maskCanvas.style.height = window.innerHeight + 'px';
      this.maskCtx.fillStyle = '#000';
      this.maskCtx.fillRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);
      this.shadowCanvas = document.createElement('canvas');
      this.shadowCtx = this.shadowCanvas.getContext('2d');
      this.shadowCanvas.width = this.maskCanvas.width;
      this.shadowCanvas.height = this.maskCanvas.height;
      this.viewCanvas = byId('v');
      this.viewCtx = this.viewCanvas.getContext('2d');
      this.viewCanvas.width = this.maskCanvas.width;
      this.viewCanvas.height = this.maskCanvas.height;
      this.viewCanvas.style.width = this.maskCanvas.style.width;
      this.viewCanvas.style.height = this.maskCanvas.style.height;
      this.viewCtx.translate(0.5, 0.5);
      this.itemsCanvas = document.createElement('canvas');
      this.itemsCtx = this.itemsCanvas.getContext('2d');
      this.itemsCanvas.width = this.maskCanvas.width;
      this.itemsCanvas.height = this.maskCanvas.height;
      this.positionMap();
      Msg.init(this.maskCtx, this.viewX, this.viewY);
      this.pos = this.tilePosToGameXY([76, 49]);
      this.exit = this.tilePosToGameXY([37, 21]);
      this.lines = [];
      this.speed = 125;
      this.monsterSpeed = 100;
      this.initLines();
      L.turnOff(3);
      this.openingText();
      return requestAnimationFrame(update);
    },
    update: function(timestamp) {
      var className, delta, dist, pg, testRange;
      if (this.lastTimestamp) {
        delta = (timestamp - this.lastTimestamp) / 1000;
      } else {
        delta = 0;
      }
      this.lastTimestamp = timestamp;
      this.timeStarted || (this.timeStarted = +new Date());
      if (this.state === 1) {
        pg = byId('pg');
        pg.style.top = parseInt(pg.style.top) - 1 + 'px';
      } else if (this.state === 2) {
        if (L.tweening) {
          L.update(delta);
        }
      } else {
        L.update(delta);
        if (right || left || up || down) {
          dist = this.speed * delta;
          testRange = 12 + dist;
          if (right) {
            if (!this.wallAt({
              x: this.pos.x + testRange,
              y: this.pos.y
            })) {
              this.pos.x += dist;
            }
            className = 'r';
          }
          if (left) {
            if (!this.wallAt({
              x: this.pos.x - testRange,
              y: this.pos.y
            })) {
              this.pos.x -= dist;
            }
            className = 'l';
          }
          if (down) {
            if (!this.wallAt({
              x: this.pos.x,
              y: this.pos.y + testRange
            })) {
              this.pos.y += dist;
            }
            className = 'd';
          }
          if (up) {
            if (!this.wallAt({
              x: this.pos.x,
              y: this.pos.y - testRange
            })) {
              this.pos.y -= dist;
            }
            className = 'u';
          }
          this.lightEl.className = this.playerEl.className = className;
          if (this.itemInRange({
            x: this.exit.x,
            y: this.exit.y - 70
          }, 80)) {
            this.win();
          }
        }
        if (window.toggleL) {
          if (L.on) {
            L.turnOff();
          } else {
            L.turnOn();
          }
          window.toggleLight = false;
        }
        this.playerTouchingOrb();
        this.playerTouchingTrigger();
        this.moveMonsters(delta);
        Msg.update(delta);
      }
      return this.draw(delta);
    },
    moveMonsters: function(delta) {
      var angDist, angle, attempts, backwards, dist, dx, dy, i, j, k, len, monster, newPos, ref, results, speed, stuck, tp1, tp2, visible;
      ref = this.monsters;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        monster = ref[i];
        if (this.itemOnScreen(monster) || monster.state === 1) {
          dx = (this.pos.x - monster.x) / 20;
          dy = (this.pos.y - monster.y) / 20;
          visible = true;
          for (i = k = 0; k <= 20; i = ++k) {
            if (this.wallAt({
              x: monster.x + dx * i,
              y: monster.y + dy * i
            })) {
              visible = false;
            }
          }
          if (visible && monster.state === 0) {
            results.push(monster.state = 1);
          } else if (monster.state === 1) {
            angDist = V.m2(monster, this.pos);
            dist = angDist.distance;
            angle = angDist.angle;
            if (visible && L.on && dist < (L.viewRadius + 20)) {
              speed = dist - L.viewRadius;
              angle += 0.5;
            } else {
              speed = this.monsterSpeed;
            }
            stuck = true;
            attempts = 0;
            if (speed < 0) {
              backwards = true;
              angle += Math.PI;
              speed = -speed;
            }
            results.push((function() {
              var results1;
              results1 = [];
              while (stuck && attempts < 20) {
                newPos = V.m1(monster, angle, speed * delta);
                tp1 = V.m1(newPos, angle + 1.0, 18.0);
                tp2 = V.m1(newPos, angle - 1.0, 18.0);
                attempts += 1;
                if (backwards && (this.wallAt(tp1) || this.wallAt(tp2))) {
                  results1.push(attempts = 999);
                } else if (this.wallAt(tp1)) {
                  angle -= 0.3;
                  results1.push(speed = speed + 15);
                } else if (this.wallAt(tp2)) {
                  angle += 0.4;
                  results1.push(speed = speed + 10);
                } else {
                  monster.x = newPos.x;
                  monster.y = newPos.y;
                  stuck = false;
                  if (this.state === 0) {
                    if (V.m3(this.pos, monster) < 22) {
                      results1.push(this.die());
                    } else {
                      results1.push(void 0);
                    }
                  } else {
                    results1.push(void 0);
                  }
                }
              }
              return results1;
            }).call(this));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    die: function() {
      var pg;
      byId('vp').className = 'ded';
      pg = byId('pg');
      pg.style.top = this.playerEl.style.top;
      pg.style.left = this.playerEl.style.left;
      this.state = 1;
      Msg.say('You had one job ... ', {
        x: -130,
        y: this.viewY - 40,
        colour: '#b00',
        size: 30
      });
      if (L.alpha < 0.4) {
        L.alpha = 0.4;
      }
      if (L.viewRadius < 20) {
        L.viewRadius = 20;
      }
      return this.printStats();
    },
    win: function() {
      byId('vp').className = 'win';
      this.state = 2;
      this.playerEl.className = 'd';
      this.lightEl.className = 'd';
      L.addPower();
      Msg.say("Thanks, you're a hero!", {
        x: -170,
        y: this.viewY - 70,
        colour: '#0c0',
        size: 30,
        hold: 10
      });
      Msg.say("I think I’ll be ok from here :)", {
        x: -170,
        y: this.viewY - 30,
        colour: '#0a0',
        size: 25,
        hold: 10
      });
      return this.printStats();
    },
    printStats: function() {
      var msg, time;
      time = Math.floor((+new Date() - this.timeStarted) / 1000);
      msg = "You lasted " + time + " seconds and collected " + this.orbCount + " of " + this.orbs.length + " light orbs";
      return Msg.say(msg, {
        x: -this.viewX + 10,
        y: -this.viewY + 20,
        hold: 100,
        size: 12
      });
    },
    draw: function() {
      this.shadowCtx.clearRect(0, 0, this.shadowCanvas.width, this.shadowCanvas.height);
      this.shadowCtx.save();
      this.shadowCtx.translate(this.viewX - this.pos.x, this.viewY - this.pos.y);
      this.itemsCtx.clearRect(0, 0, this.itemsCanvas.width, this.itemsCanvas.height);
      this.itemsCtx.save();
      this.itemsCtx.translate(this.viewX - this.pos.x, this.viewY - this.pos.y);
      this.maskCtx.fillStyle = '#000';
      this.maskCtx.fillRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);
      this.drawOrbs();
      this.drawMonsters();
      this.drawLineShadows();
      this.drawPlayerShadow();
      this.drawExit(this.itemsCtx);
      this.itemsCtx.restore();
      this.shadowCtx.restore();
      this.compositeCanvas();
      return Msg.draw();
    },
    wallAt: function(pos) {
      return Map.pixelAt(pos.x, pos.y)[3] > 10;
    },
    compositeCanvas: function() {
      this.viewCtx.fillStyle = 'red';
      this.viewCtx.fillRect(0, 0, this.viewCanvas.width, this.viewCanvas.height);
      this.viewCtx.drawImage(Map.floorCanvas, this.viewX - this.pos.x, this.viewY - this.pos.y);
      this.itemsCtx.globalCompositeOperation = 'destination-out';
      this.itemsCtx.drawImage(this.shadowCanvas, 0, 0);
      this.itemsCtx.globalCompositeOperation = 'source-over';
      this.maskCtx.drawImage(this.shadowCanvas, 0, 0);
      this.viewCtx.drawImage(this.itemsCanvas, 0, 0);
      if (L.on) {
        this.viewCtx.globalAlpha = 0.7;
        this.viewCtx.drawImage(this.shadowCanvas, 0, 0);
        this.viewCtx.globalAlpha = 1;
      }
      this.viewCtx.drawImage(Map.canvas, this.viewX - this.pos.x, this.viewY - this.pos.y);
      return this.drawLightMask();
    },
    drawPlayerShadow: function() {
      var grd, radius;
      radius = 24 / 2;
      this.shadowCtx.save();
      this.shadowCtx.translate(this.pos.x, this.pos.y + 24 / 2);
      this.shadowCtx.scale(1, 0.25);
      grd = this.shadowCtx.createRadialGradient(0, 0, 0, 0, 0, radius);
      grd.addColorStop(0, 'rgba(0,0,0,0.6)');
      grd.addColorStop(1, 'rgba(0,0,0,0)');
      this.shadowCtx.fillStyle = grd;
      this.shadowCtx.beginPath();
      this.shadowCtx.arc(0, 0, radius, 0, Math.PI * 2);
      this.shadowCtx.fill();
      return this.shadowCtx.restore();
    },
    playerTouchingOrb: function() {
      var i, j, len, orb, ref, results;
      ref = this.orbs;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        orb = ref[i];
        if (this.itemInRange(orb, this.tileSize) && !orb.used) {
          L.addPower();
          this.orbCount += 1;
          results.push(orb.used = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    playerTouchingTrigger: function() {
      var j, len, ref, results, t;
      ref = this.triggers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        if (this.itemInRange(t, t.r) && !t.used) {
          if (t.msg) {
            Msg.say(t.msg);
          }
          results.push(t.used = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    drawOrbs: function() {
      var ctx, glowGradient, glowRadius, grd, j, len, maskRadius, orb, orbGradient, orbRadius, ref;
      ctx = this.itemsCtx;
      glowRadius = 15;
      orbRadius = 4;
      glowGradient = ctx.createRadialGradient(0, 0, orbRadius, 0, 0, glowRadius);
      glowGradient.addColorStop(0, 'rgba(143,194,242,0.4)');
      glowGradient.addColorStop(1, 'rgba(191,226,226,0)');
      orbGradient = ctx.createRadialGradient(1, -1, 1, 0, 0, orbRadius);
      orbGradient.addColorStop(0, '#bfe2e2');
      orbGradient.addColorStop(1, '#8fc2f2');
      this.maskCtx.fillStyle = "#000";
      maskRadius = glowRadius * 1.5;
      grd = this.maskCtx.createRadialGradient(0, 0, 0, 0, 0, maskRadius);
      grd.addColorStop(0, "rgba(255,255,255,0.8)");
      grd.addColorStop(1, 'rgba(255,255,255,0)');
      this.maskCtx.globalCompositeOperation = 'destination-out';
      this.maskCtx.fillStyle = grd;
      ref = this.orbs;
      for (j = 0, len = ref.length; j < len; j++) {
        orb = ref[j];
        if (this.itemOnScreen(orb) && !orb.used) {
          ctx.save();
          ctx.translate(orb.x, orb.y);
          ctx.fillStyle = glowGradient;
          ctx.beginPath();
          ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = orbGradient;
          ctx.beginPath();
          ctx.arc(0, 0, orbRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          this.maskCtx.save();
          this.maskCtx.translate(orb.x - this.pos.x + this.viewX, orb.y - this.pos.y + this.viewY);
          this.maskCtx.beginPath();
          this.maskCtx.arc(0, 0, maskRadius, 0, Math.PI * 2);
          this.maskCtx.fill();
          this.maskCtx.restore();
        }
      }
      return this.maskCtx.globalCompositeOperation = 'source-over';
    },
    drawMonsters: function() {
      var angDist, ctx, eyeCtx, j, len, monster, radius, ref, results;
      ctx = this.itemsCtx;
      eyeCtx = this.maskCtx;
      radius = 12;
      ref = this.monsters;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        monster = ref[j];
        if (this.itemOnScreen(monster)) {
          angDist = V.m2(this.pos, monster);
          ctx.save();
          ctx.translate(monster.x, monster.y);
          ctx.rotate(angDist.angle);
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#a10';
          ctx.scale(0.5, 1.0);
          ctx.beginPath();
          ctx.arc(-13, 4, 3, 0, Math.PI * 2);
          ctx.arc(-13, -4, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          eyeCtx.save();
          eyeCtx.translate(monster.x - this.pos.x + this.viewX, monster.y - this.pos.y + this.viewY);
          eyeCtx.rotate(angDist.angle);
          eyeCtx.fillStyle = '#f20';
          eyeCtx.scale(0.5, 1.0);
          eyeCtx.beginPath();
          eyeCtx.arc(-13, 4, 3, 0, Math.PI * 2);
          eyeCtx.arc(-13, -4, 3, 0, Math.PI * 2);
          eyeCtx.fill();
          results.push(eyeCtx.restore());
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    itemInRange: function(pos, range) {
      return (Math.abs(pos.x - this.pos.x) < range) && (Math.abs(pos.y - this.pos.y) < range);
    },
    itemOnScreen: function(pos) {
      return (Math.abs(pos.x - this.pos.x) < this.viewX) && (Math.abs(pos.y - this.pos.y) < this.viewY);
    },
    drawLines: function() {
      var j, l, len, ref;
      this.shadowCtx.strokeStyle = '#800';
      this.shadowCtx.beginPath();
      ref = this.lines;
      for (j = 0, len = ref.length; j < len; j++) {
        l = ref[j];
        this.shadowCtx.moveTo(l[0].x, l[0].y);
        this.shadowCtx.lineTo(l[1].x, l[1].y);
      }
      return this.shadowCtx.stroke();
    },
    drawLineShadows: function() {
      var angDist1, angDist2, angle, delta, j, l, len, p1, p2, ref, results;
      this.shadowCtx.fillStyle = '#000';
      this.shadowCtx.strokeStyle = '#000';
      ref = this.lines;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        l = ref[j];
        p1 = l[0];
        if (this.itemOnScreen(p1)) {
          p2 = l[1];
          angDist1 = V.m2(this.pos, p1);
          angDist2 = V.m2(this.pos, p2);
          if (l[2]) {
            angle = angDist1.angle;
            delta = angle - l[2].ang;
            if (delta < Math.PI) {
              delta += Math.PI * 2;
            }
            if (delta > Math.PI) {
              delta -= Math.PI * 2;
            }
            if (delta < 0) {
              results.push(this.drawShadow(p1, p2, angDist1.angle, angDist2.angle));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    drawShadow: function(p1, p2, ang1, ang2) {
      var end1, end2;
      this.shadowCtx.beginPath();
      end1 = V.m1(p1, ang1, 900);
      end2 = V.m1(p2, ang2, 900);
      this.shadowCtx.moveTo(p1.x, p1.y);
      this.shadowCtx.lineTo(end1.x, end1.y);
      this.shadowCtx.lineTo(end2.x, end2.y);
      this.shadowCtx.lineTo(p2.x, p2.y);
      this.shadowCtx.lineTo(p1.x, p1.y);
      this.shadowCtx.fill();
      this.shadowCtx.beginPath();
      this.shadowCtx.moveTo(p1.x, p1.y);
      this.shadowCtx.lineTo(end1.x, end1.y);
      return this.shadowCtx.stroke();
    },
    drawLightMask: function() {
      var grd, radius;
      this.maskCtx.fillStyle = "#000";
      radius = L.viewRadius;
      grd = this.maskCtx.createRadialGradient(this.viewX, this.viewY, radius / 4, this.viewX, this.viewY, radius);
      grd.addColorStop(0, "rgba(255,255,255," + L.alpha + ")");
      grd.addColorStop(1, 'rgba(255,255,255,0)');
      this.maskCtx.globalCompositeOperation = 'destination-out';
      this.maskCtx.fillStyle = grd;
      this.maskCtx.beginPath();
      this.maskCtx.arc(this.viewX, this.viewY, radius, 0, Math.PI * 2);
      this.maskCtx.fill();
      return this.maskCtx.globalCompositeOperation = 'source-over';
    },
    drawExit: function(ctx) {
      var grd, i, j, k, len, maskRadius, radius, ray, ref, x;
      if (this.itemOnScreen(this.exit)) {
        radius = this.tileSize;
        if (!this.lightRays) {
          this.lightRays = [];
          for (i = j = 0; j <= 5; i = ++j) {
            x = randInt(-radius, radius * 2);
            this.lightRays.push({
              x: x,
              y: randInt(-7, 14),
              w: randInt(2, radius - x),
              h: randInt(100, 50)
            });
          }
        }
        ctx.save();
        ctx.translate(this.exit.x, this.exit.y);
        ctx.scale(1, 0.4);
        grd = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
        grd.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        grd.addColorStop(1, 'rgba(255, 255, 255, 0.2)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.translate(this.exit.x, this.exit.y);
        ref = this.lightRays;
        for (k = 0, len = ref.length; k < len; k++) {
          ray = ref[k];
          grd = ctx.createLinearGradient(ray.x, ray.y, ray.x, ray.y - ray.h);
          grd.addColorStop(0, "rgba(255, 255, 255, " + (0.3 + Math.random() / 5) + ")");
          grd.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.moveTo(ray.x, ray.y);
          ctx.lineTo(ray.x - 0.2 * ray.h, ray.y - ray.h);
          ctx.lineTo(ray.x - 0.2 * ray.h + ray.w, ray.y - ray.h);
          ctx.lineTo(ray.x + ray.w, ray.y);
          ctx.fill();
        }
        ctx.restore();
        this.maskCtx.fillStyle = "#000";
        maskRadius = radius * 1.5;
        grd = this.maskCtx.createRadialGradient(0, 0, 0, 0, 0, maskRadius);
        grd.addColorStop(0, "rgba(255,255,255,0.8)");
        grd.addColorStop(1, 'rgba(255,255,255,0)');
        this.maskCtx.globalCompositeOperation = 'destination-out';
        this.maskCtx.fillStyle = grd;
        this.maskCtx.save();
        this.maskCtx.translate(this.exit.x - this.pos.x + this.viewX, this.exit.y - this.pos.y + this.viewY);
        this.maskCtx.scale(1, 0.4);
        this.maskCtx.beginPath();
        this.maskCtx.arc(0, 0, maskRadius, 0, Math.PI * 2);
        this.maskCtx.fill();
        this.maskCtx.restore();
        return this.maskCtx.globalCompositeOperation = 'source-over';
      }
    },
    initLines: function() {
      return this.lines = Map.lines();
    },
    positionMap: function() {
      this.viewX = window.innerWidth / 4;
      return this.viewY = window.innerHeight / 4;
    },
    initGameParams: function(params) {
      var j, k, len, len1, len2, monster, n, pos, ref, ref1, ref2, results, trigger;
      this.monsters = [];
      this.orbs = [];
      this.triggers = [];
      ref = params.monsters;
      for (j = 0, len = ref.length; j < len; j++) {
        pos = ref[j];
        monster = this.tilePosToGameXY(pos);
        monster.state = 0;
        this.monsters.push(monster);
      }
      ref1 = params.orbs;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        pos = ref1[k];
        this.orbs.push(this.tilePosToGameXY(pos));
      }
      ref2 = params.triggers;
      results = [];
      for (n = 0, len2 = ref2.length; n < len2; n++) {
        trigger = ref2[n];
        trigger.x *= this.tileSize;
        trigger.y *= this.tileSize;
        trigger.r = trigger.r * this.tileSize / 2;
        results.push(this.triggers.push(trigger));
      }
      return results;
    },
    tilePosToGameXY: function(xy) {
      return {
        x: (xy[0] + .5) * this.tileSize,
        y: (xy[1] + .5) * this.tileSize
      };
    },
    openingText: function() {
      Msg.say('...');
      return setTimeout((function() {
        return Msg.say("How did I end up here?");
      }), 2000);
    }
  };

  window.randSeed = 1234;

  window.randomX = function() {
    var x;
    x = Math.sin(randSeed++) * 10000;
    return x - Math.floor(x);
  };

  window.randInt = function(min, range) {
    return Math.floor(randomX() * range) + min;
  };

  window.update = function(timestamp) {
    Game.update(timestamp);
    window.requestAnimationFrame(update);
    return true;
  };

  window.byId = function(elementId) {
    return document.getElementById(elementId);
  };

  window.up = window.right = window.down = window.left = false;

  window.onkeydown = function(e) {
    if (e.keyCode === 32) {
      window.toggleLight = true;
    }
    if (e.keyCode === 38 || e.keyCode === 90 || e.keyCode === 87) {
      window.up = true;
    }
    if (e.keyCode === 39 || e.keyCode === 68) {
      window.right = true;
    }
    if (e.keyCode === 40 || e.keyCode === 83) {
      window.down = true;
    }
    if (e.keyCode === 37 || e.keyCode === 65 || e.keyCode === 81) {
      return window.left = true;
    }
  };

  window.onkeyup = function(e) {
    if (e.keyCode === 38 || e.keyCode === 90 || e.keyCode === 87) {
      window.up = false;
    }
    if (e.keyCode === 39 || e.keyCode === 68) {
      window.right = false;
    }
    if (e.keyCode === 40 || e.keyCode === 83) {
      window.down = false;
    }
    if (e.keyCode === 37 || e.keyCode === 65 || e.keyCode === 81) {
      return window.left = false;
    }
  };

  window.initGame = function() {
    return Game.init();
  };

}).call(this);
